<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Bloom Filter in Go | kiennt26's home</title><link rel=canonical href=https://ntk148v.github.io/posts/bloom-filter/><meta property="og:title" content="Bloom Filter in Go"><meta property="og:type" content="article"><meta property="og:url" content="https://ntk148v.github.io/posts/bloom-filter/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bloom Filter in Go"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Bloom Filter in Go","url":"https:\/\/ntk148v.github.io\/posts\/bloom-filter\/","datePublished":"2026-02-21T10:29:11\u002b07:00","dateModified":"2026-02-21T11:10:44\u002b07:00","author":{"@type":"Person","name":"Kien Nguyen-Tuan"}}</script><link rel=apple-touch-icon sizes=57x57 href=/favicon_io/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/favicon_io/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/favicon_io/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/favicon_io/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/favicon_io/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/favicon_io/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/favicon_io/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/favicon_io/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/favicon_io/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/favicon_io/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon_io/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon_io/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon_io/favicon-16x16.png><link rel=manifest href=/favicon_io/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/favicon_io/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=/css/main.min.383a7d1382f8498b5f1577cdce60b99b9a4f5c7b7aa954cbab4d0a7f85f73262.css integrity="sha256-ODp9E4L4SYtfFXfNzmC5m5pPXHt6qVTLq00Kf4X3MmI=" crossorigin=anonymous><link rel=stylesheet href=/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css integrity="sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=" crossorigin=anonymous></head><body><a href=#main-content class=skip-link>Skip to content</a><header><nav class=path-nav><ol><li>/
<a href=/>kiennt26's home</a>
/</li><li><a href=/posts/>Posts</a>
/</li><li class=current><a href=/posts/bloom-filter/>Bloom Filter in Go</a></li></ol></nav></header><main id=main-content><h1>Bloom Filter in Go</h1><div class=terms-list><ul><li><a href=/tags/tech/>#Tech</a></li><li><a href=/tags/golang/>#Golang</a></li></ul></div><nav class=toc><strong>Table of contents</strong><div class=toc-content><nav id=TableOfContents><ol><li><a href=#what-is-bloom-filter>What is Bloom filter?</a></li><li><a href=#the-core-architect>The Core architect</a></li><li><a href=#how-it-works-step-by-step>How It Works: Step-by-Step</a><ol><li><a href=#adding-an-element>Adding an Element</a></li><li><a href=#checking-for-an-element-lookup>Checking for an Element (Lookup)</a></li></ol></li><li><a href=#why-false-positives-happen>Why False Positives Happen</a></li><li><a href=#use-cases>Use cases</a></li><li><a href=#the-implementation>The Implementation</a></li><li><a href=#benchmarking-the-impact>Benchmarking the Impact</a><ol><li><a href=#the-results>The Results</a></li></ol></li></ol></nav></div></nav><p>Source:</p><ul><li><a href=https://en.wikipedia.org/wiki/Bloom_filter>https://en.wikipedia.org/wiki/Bloom_filter</a></li><li><a href=https://redis.io/docs/latest/develop/data-types/probabilistic/bloom-filter/>https://redis.io/docs/latest/develop/data-types/probabilistic/bloom-filter/</a></li><li><a href=https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree#table_engine-mergetree-data_skipping-indexes>https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree#table_engine-mergetree-data_skipping-indexes</a></li></ul><h2 id=what-is-bloom-filter>What is Bloom filter?</h2><p>When building high-performance systems, minimizing expensive operations like disk reads or remote database queries is critical.</p><p>A Bloom filter is a highly space-efficient, probabilistic data structure designed to test whether an element is a member of a set. It was conceived by Burton Howard Bloom in 1970.</p><p>Unlike standard data structures like hash tables or binary search trees that store the actual data, a Bloom filter only stores a cryptographic representation of the data. Because it does not store the raw elements, it requires a fraction of the memory.</p><p>The defining characteristic of a Bloom filter is its ironclad rule regarding accuracy:</p><ul><li><strong>False Negatives are impossible</strong>: If the filter says an item is not present, it is 100% guaranteed to not be there.</li><li><strong>False Positives are possible</strong>: If the filter says an item is present, it means the item is probably there, but it could be a false alarm caused by overlapping data.</li></ul><p>By placing a Bloom filter in front of a slow datastore, you can instantly filter out requests for missing items, saving massive amounts of latency and computational overhead.</p><h2 id=the-core-architect>The Core architect</h2><p>To understand how it works, you need to understand its two primary components:</p><ol><li><p><strong>The Bit Array (m):</strong><br>The filter begins as an array of <em>m</em> bits, all initially set to 0.</p></li><li><p><strong>The Hash Functions (k):</strong><br>The filter uses <em>k</em> independent hash functions. When you feed data into a hash function, it outputs a seemingly random, uniform integer. In a Bloom filter, this output is mapped to an index position within the <em>m</em>-bit array.</p></li></ol><p>To initialize an optimal Bloom filter, we need two parameters based on our expected capacity (<em>n</em>) and acceptable false-positive probability (<em>p</em>):</p><ol><li><strong>Size of the bit array (<code>m</code>):</strong></li></ol><p><figure><img src=https://wikimedia.org/api/rest_v1/media/math/render/svg/5a90ab21c84c30f655ae6b0b9ea78a407738a487 alt loading=lazy></figure></p><ol start=2><li><strong>Number of hash functions (<code>k</code>):</strong></li></ol><p><figure><img src=https://wikimedia.org/api/rest_v1/media/math/render/svg/fabc2770225ac59fe42a78f75ea89de650f0130c alt loading=lazy></figure></p><p>Instead of actually running <em>k</em> separate hash functions (which is computationally expensive), we will use the <strong>Kirsch–Mitzenmacher optimization</strong>. We can hash the data once into a 64-bit integer, split it into two 32-bit integers (<em>h₁</em> and <em>h₂</em>), and simulate <em>k</em> hash functions using the formula: <code>hash_i = h_1 + i * h_2</code></p><h2 id=how-it-works-step-by-step>How It Works: Step-by-Step</h2><h3 id=adding-an-element>Adding an Element</h3><p>When you want to add an item (for example, the string <code>"user_123"</code>) to the Bloom filter:</p><ul><li>The item is passed through all <em>k</em> hash functions.</li><li>Each hash function calculates a specific index position in the bit array.</li><li>The bits at those specific indices are changed from 0 to 1.</li><li>If a bit is already 1 from a previous insertion, it simply stays 1.</li></ul><p>Let’s explore how this works with a concrete example. Imagine we created a Bloom filter of 3 bits and 2 hash functions and inserted the strings &ldquo;Hello&rdquo; and &ldquo;Bloom&rdquo; into the filter. If the hash functions match an incoming value with an index in the bit array, the Bloom filter will make sure the bit at that position in the array is 1.</p><p><figure><img src=https://tinybird.co/api/blog/images/posts/2023-06-22-using-bloom-filter-text-indexes-in-clickhouse/6491f32be7473574962d2445_E9bpstiXrDlFsssHIaLa9wplBULJUObOjuZ-Z6YjpPlOFCkQwKL0P4BOrMSExibtSRzXoS2oGe-9NbPSC5T5Y_U-0PWr4zh0u5Lrg7eU_EuWenI1bBvW2Dnicd5mO2G3Vr5NcYC7_yNxGBTGY_Wo4OE-11.gif alt=tinybird-bloom-filter-gif loading=lazy><figcaption>tinybird-bloom-filter-gif</figcaption></figure></p><p>In this example, &ldquo;Hello&rdquo; was hashed to 1 by the first hash function and 3 by the second hash function. So, the Bloom filter made sure the bits at index 1 and 3 were flipped to 1. Then, &ldquo;Bloom&rdquo; was hashed to 1 and 2. The Bloom filter made sure those were both a 1 as well (even though position 1 already had a 1).</p><h3 id=checking-for-an-element-lookup>Checking for an Element (Lookup)</h3><p>When you want to check if <code>"user_123"</code> is in the filter:</p><ul><li>The item is passed through the exact same <em>k</em> hash functions used during insertion.</li><li>The filter checks the bits at the resulting indices.</li><li><strong>If any of the bits are 0:</strong><br>The item has definitely never been added. If it had been added, all those bits would have been flipped to 1. The operation safely stops here.</li><li><strong>If all of the bits are 1:</strong><br>The item is <em>probably</em> in the set.</li></ul><h2 id=why-false-positives-happen>Why False Positives Happen</h2><p>The reason an item is only <em>probably</em> in the set is due to hash collisions.</p><p>Imagine you add <code>"Item A"</code> and it flips bits at indices 2, 5, and 8.<br>Then you add <code>"Item B"</code> and it flips bits at indices 4, 11, and 15.</p><p>Now, you check for <code>"Item C"</code>. By pure coincidence, the hash functions for <code>"Item C"</code> point to indices 2, 8, and 15. The filter checks those positions, sees they are all 1, and reports that <code>"Item C"</code> is present.</p><p>This is a false positive, caused by the overlapping bits of <code>"Item A"</code> and <code>"Item B"</code>.</p><h2 id=use-cases>Use cases</h2><p>Today, Bloom filters are widely used across many technologies including databases, networks, and distributed systems. They serve to reduce the need for expensive disk or network operations, thus improving performance. For example:</p><ul><li>Databases may use Bloom filters to avoid costly disk reads when searching for nonexistent keys.</li><li>Web browsers utilize them to check URLs against a list of malicious websites.</li><li>Web applications use them to determine whether a user ID is already taken.</li><li>Recommendation engines use them to filter out previously shown posts.</li><li>Spellcheckers use them to check words for misspellings and/or profanity.</li></ul><h2 id=the-implementation>The Implementation</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-sh data-lang=sh><span style=display:flex><span>mkdir bloom
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic>cd</span> bloom
</span></span><span style=display:flex><span>go mod init bloom
</span></span><span style=display:flex><span>touch bloom.go bloom_test.go
</span></span></code></pre></div><p>This implementation uses a <code>sync.RWMutex</code> to allow concurrent reads (<code>Contains</code>) while ensuring exclusive access during writes (<code>Add</code>). We use a <code>[]uint64</code> slice for maximum memory density.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>package</span> bloom
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#666;font-style:italic>&#34;hash/fnv&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#666;font-style:italic>&#34;math&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#666;font-style:italic>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic>type</span> BloomFilter <span style=font-weight:700;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>    mu     sync.RWMutex
</span></span><span style=display:flex><span>    bitset []<span style=font-weight:700>uint64</span>
</span></span><span style=display:flex><span>    m      <span style=font-weight:700>uint64</span>
</span></span><span style=display:flex><span>    k      <span style=font-weight:700>uint64</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic>func</span> <span style=color:#666;font-weight:700;font-style:italic>New</span>(n <span style=font-weight:700>uint64</span>, p <span style=font-weight:700>float64</span>) *BloomFilter {
</span></span><span style=display:flex><span>    mFloat := -(<span style=font-weight:700;font-style:italic>float64</span>(n) * math.<span style=color:#666;font-weight:700;font-style:italic>Log</span>(p)) / (math.<span style=color:#666;font-weight:700;font-style:italic>Pow</span>(math.<span style=color:#666;font-weight:700;font-style:italic>Log</span>(2), 2))
</span></span><span style=display:flex><span>    kFloat := (mFloat / <span style=font-weight:700;font-style:italic>float64</span>(n)) * math.<span style=color:#666;font-weight:700;font-style:italic>Log</span>(2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    m := <span style=font-weight:700;font-style:italic>uint64</span>(math.<span style=color:#666;font-weight:700;font-style:italic>Ceil</span>(mFloat))
</span></span><span style=display:flex><span>    k := <span style=font-weight:700;font-style:italic>uint64</span>(math.<span style=color:#666;font-weight:700;font-style:italic>Ceil</span>(kFloat))
</span></span><span style=display:flex><span>    <span style=font-weight:700>if</span> k &lt; 1 {
</span></span><span style=display:flex><span>        k = 1
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> &amp;BloomFilter{
</span></span><span style=display:flex><span>        bitset: <span style=font-weight:700;font-style:italic>make</span>([]<span style=font-weight:700>uint64</span>, (m+63)/64),
</span></span><span style=display:flex><span>        m:      m,
</span></span><span style=display:flex><span>        k:      k,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic>func</span> (bf *BloomFilter) <span style=color:#666;font-weight:700;font-style:italic>getHashes</span>(data []<span style=font-weight:700>byte</span>) (<span style=font-weight:700>uint32</span>, <span style=font-weight:700>uint32</span>) {
</span></span><span style=display:flex><span>    h := fnv.<span style=color:#666;font-weight:700;font-style:italic>New64a</span>()
</span></span><span style=display:flex><span>    h.<span style=color:#666;font-weight:700;font-style:italic>Write</span>(data)
</span></span><span style=display:flex><span>    hash64 := h.<span style=color:#666;font-weight:700;font-style:italic>Sum64</span>()
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> <span style=font-weight:700;font-style:italic>uint32</span>(hash64 &amp; ((1&lt;&lt;32) - 1)), <span style=font-weight:700;font-style:italic>uint32</span>(hash64 &gt;&gt; 32)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic>func</span> (bf *BloomFilter) <span style=color:#666;font-weight:700;font-style:italic>Add</span>(data []<span style=font-weight:700>byte</span>) {
</span></span><span style=display:flex><span>    h1, h2 := bf.<span style=color:#666;font-weight:700;font-style:italic>getHashes</span>(data)
</span></span><span style=display:flex><span>    bf.mu.<span style=color:#666;font-weight:700;font-style:italic>Lock</span>()
</span></span><span style=display:flex><span>    <span style=font-weight:700>defer</span> bf.mu.<span style=color:#666;font-weight:700;font-style:italic>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> i := <span style=font-weight:700;font-style:italic>uint64</span>(0); i &lt; bf.k; i++ {
</span></span><span style=display:flex><span>        idx := (<span style=font-weight:700;font-style:italic>uint64</span>(h1) + i*<span style=font-weight:700;font-style:italic>uint64</span>(h2)) % bf.m
</span></span><span style=display:flex><span>        bf.bitset[idx/64] |= 1 &lt;&lt; (idx % 64)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic>func</span> (bf *BloomFilter) <span style=color:#666;font-weight:700;font-style:italic>Contains</span>(data []<span style=font-weight:700>byte</span>) <span style=font-weight:700>bool</span> {
</span></span><span style=display:flex><span>    h1, h2 := bf.<span style=color:#666;font-weight:700;font-style:italic>getHashes</span>(data)
</span></span><span style=display:flex><span>    bf.mu.<span style=color:#666;font-weight:700;font-style:italic>RLock</span>()
</span></span><span style=display:flex><span>    <span style=font-weight:700>defer</span> bf.mu.<span style=color:#666;font-weight:700;font-style:italic>RUnlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> i := <span style=font-weight:700;font-style:italic>uint64</span>(0); i &lt; bf.k; i++ {
</span></span><span style=display:flex><span>        idx := (<span style=font-weight:700;font-style:italic>uint64</span>(h1) + i*<span style=font-weight:700;font-style:italic>uint64</span>(h2)) % bf.m
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> (bf.bitset[idx/64] &amp; (1 &lt;&lt; (idx % 64))) == 0 {
</span></span><span style=display:flex><span>            <span style=font-weight:700>return</span> <span style=font-weight:700>false</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> <span style=font-weight:700>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=benchmarking-the-impact>Benchmarking the Impact</h2><p>To demonstrate the value of the filter, we simulate a slow system (like a database taking 50 microseconds to respond) and benchmark looking up an item that does not exist.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>package</span> bloom
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#666;font-style:italic>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#666;font-style:italic>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic>func</span> <span style=color:#666;font-weight:700;font-style:italic>expensiveDatabaseLookup</span>(key <span style=font-weight:700>string</span>) <span style=font-weight:700>bool</span> {
</span></span><span style=display:flex><span>    time.<span style=color:#666;font-weight:700;font-style:italic>Sleep</span>(50 * time.Microsecond)
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> <span style=font-weight:700>false</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic>func</span> <span style=color:#666;font-weight:700;font-style:italic>BenchmarkWithoutBloomFilter</span>(b *testing.B) {
</span></span><span style=display:flex><span>    key := <span style=color:#666;font-style:italic>&#34;missing-user-id&#34;</span>
</span></span><span style=display:flex><span>    b.<span style=color:#666;font-weight:700;font-style:italic>ResetTimer</span>()
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> i := 0; i &lt; b.N; i++ {
</span></span><span style=display:flex><span>        _ = <span style=color:#666;font-weight:700;font-style:italic>expensiveDatabaseLookup</span>(key)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic>func</span> <span style=color:#666;font-weight:700;font-style:italic>BenchmarkWithBloomFilter</span>(b *testing.B) {
</span></span><span style=display:flex><span>    bf := <span style=color:#666;font-weight:700;font-style:italic>New</span>(1_000_000, 0.01)
</span></span><span style=display:flex><span>    key := []<span style=font-weight:700;font-style:italic>byte</span>(<span style=color:#666;font-style:italic>&#34;missing-user-id&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    b.<span style=color:#666;font-weight:700;font-style:italic>ResetTimer</span>()
</span></span><span style=display:flex><span>    <span style=font-weight:700>for</span> i := 0; i &lt; b.N; i++ {
</span></span><span style=display:flex><span>        <span style=color:#888;font-style:italic>// Fast path: Bloom filter checks first.</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>if</span> bf.<span style=color:#666;font-weight:700;font-style:italic>Contains</span>(key) {
</span></span><span style=display:flex><span>            _ = <span style=color:#666;font-weight:700;font-style:italic>expensiveDatabaseLookup</span>(<span style=font-weight:700;font-style:italic>string</span>(key))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=the-results>The Results</h3><p>Running <code>go test -bench=. -benchtime=2s</code> yields stark results:</p><ul><li><strong>Without Bloom Filter:</strong> ~55,000 ns/op</li><li><strong>With Bloom Filter:</strong> ~60 ns/op</li></ul><p>By verifying that the item is definitely not in the set, the Bloom filter intercepts the request in nanoseconds, completely bypassing the expensive 50-microsecond database penalty.</p><div class=time><time datetime=2026-02-21>2026-02-21&nbsp;</time></div><div class=comments><script src=https://giscus.app/client.js data-repo=ntk148v/ntk148v.github.io data-repo-id=R_kgDOIWtaXA data-category="Show and tell" data-category-id=DIC_kwDOIWtaXM4CSU-P data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></div><div class=terminal-nav><div class=back-nav><a href=/posts/ class=back-link>../</a></div></div></main><footer><p>&copy; Copyright 2026 &#183;
<a href=https://github.com/ntk148v/shibui>shibui</a></p></footer></body></html>