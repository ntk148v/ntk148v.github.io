<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Etcd on kiennt26's home</title><link>https://ntk148v.github.io/tags/etcd/</link><description>Recent content in Etcd on kiennt26's home</description><generator>Hugo</generator><language>en-us</language><managingEditor>kiennt2609@gmail.com (Kien Nguyen-Tuan)</managingEditor><webMaster>kiennt2609@gmail.com (Kien Nguyen-Tuan)</webMaster><lastBuildDate>Wed, 25 Dec 2024 10:38:20 +0700</lastBuildDate><atom:link href="https://ntk148v.github.io/tags/etcd/index.xml" rel="self" type="application/rss+xml"/><item><title>Operate Etcd cluster</title><link>https://ntk148v.github.io/posts/operate-etcd-cluster/</link><pubDate>Tue, 28 Apr 2020 11:24:04 +0700</pubDate><author>kiennt2609@gmail.com (Kien Nguyen-Tuan)</author><guid>https://ntk148v.github.io/posts/operate-etcd-cluster/</guid><description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: This is my perspective aggregation. You can easily find these such of knowledges in &lt;a href="#5-references"&gt;the references&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id="context"&gt;Context&lt;/h2&gt;
&lt;p&gt;Etcd Version &lt;code&gt;v3.4.0&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="requirements"&gt;Requirements&lt;/h2&gt;
&lt;h3 id="number-of-nodes"&gt;Number of nodes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&amp;gt;= 3 nodes. A etcd cluster needs a majority of nodes, a quorum to agree on updates to the cluster state. For a cluster with &lt;strong&gt;n-members&lt;/strong&gt;, quorum is &lt;strong&gt;(n/2)+1&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="cpus"&gt;CPUs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Etcd doesn&amp;rsquo;t require a lot of CPU capacity.&lt;/li&gt;
&lt;li&gt;Typical clusters need &lt;strong&gt;2-4 cores&lt;/strong&gt; to run smoothly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="memory"&gt;Memory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Etcd performance depends on having enough memory (cache key-value data, tracking watchers&amp;hellip;).&lt;/li&gt;
&lt;li&gt;Typical &lt;strong&gt;8GB&lt;/strong&gt; is enough.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="disk"&gt;Disk&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;An etcd cluster is very sensitive to disk latencies. Since etcd must persist proposals to its log, disk activity from other processes may cause long &lt;code&gt;fsync&lt;/code&gt; latencies. The upshot is etcd may miss heartbeats, causing request timeouts and temporary leader loss. An etcd server can sometimes stably run alongside these processes when given a high disk priority.&lt;/li&gt;
&lt;li&gt;Check whether a disk is fast enough for etcd using &lt;a href="https://github.com/axboe/fio"&gt;fio&lt;/a&gt;. If the 99th percentile of fdatasync is &lt;strong&gt;&amp;lt;10ms&lt;/strong&gt;, your storage is ok.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;$ fio --rw&lt;span class="o"&gt;=&lt;/span&gt;write --ioengine&lt;span class="o"&gt;=&lt;/span&gt;sync --fdatasync&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; --directory&lt;span class="o"&gt;=&lt;/span&gt;test-data &lt;span class="se"&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="se"&gt;&lt;/span&gt; --size&lt;span class="o"&gt;=&lt;/span&gt;22m --bs&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2300&lt;/span&gt; --name&lt;span class="o"&gt;=&lt;/span&gt;mytest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SSD&lt;/strong&gt; is recommended.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="network"&gt;Network&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Etcd cluster should be deployed in a fast and reliable network. Low latency ensures etcd members can communicate fast. High bandwidth can reduce the time to recover a failed etcd member.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1GbE&lt;/strong&gt; is sufficient for common etcd.&lt;/li&gt;
&lt;li&gt;Note that the network isn&amp;rsquo;t the only source of latency. Each request and response may be impacted by slow disks on both the leader and followers.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tuning"&gt;Tuning&lt;/h2&gt;
&lt;h3 id="time-parameters"&gt;Time parameters&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Heartbeat interval&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;The frequency with which the leader will notify followers that it is still the leader.&lt;/li&gt;
&lt;li&gt;Default: &lt;strong&gt;100ms&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Best practice: &lt;strong&gt;Around 0.5-1.5 x round-trip time (RTT) between members&lt;/strong&gt;. Measure RTT with &lt;code&gt;ping&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Tradeoff: Too low -&amp;gt; etcd will send unnecessary messages -&amp;gt; increase the usage of CPU and network resources. Too high -&amp;gt; leads to high election timeout.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Election timeout&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;How long a follower node will go without hearing a heartbeat before attempting to become leader itself.&lt;/li&gt;
&lt;li&gt;Default: &lt;strong&gt;1000ms&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Best practice: &lt;strong&gt;&amp;gt;= 10 x RTT and &amp;lt; 50s&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The heartbeat interval and election timeout value should be &lt;strong&gt;the same for all members in one cluster&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Command line arguments:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;$ etcd --heartbeat-interval&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt; --election-timeout&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;500&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Environment variables:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;$ &lt;span class="nv"&gt;ETCD_HEARTBEAT_INTERVAL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="nv"&gt;ETCD_ELECTION_TIMEOUT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;500&lt;/span&gt; etcd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="disk-1"&gt;Disk&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;An etcd server can sometimes stably run alongside these processes when given a high disk priority using &lt;a href="https://linux.die.net/man/1/ionice"&gt;ionice&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# best effort, highest priority&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;$ sudo ionice -c2 -n0 -p &lt;span class="sb"&gt;`&lt;/span&gt;pgrep etcd&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="snapshot"&gt;Snapshot&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;etcd appends all key changes to a log file -&amp;gt; huge log that grows forever :point_up:&lt;/li&gt;
&lt;li&gt;Solution: Make periodic snapshots (save the current and remove old logs).&lt;/li&gt;
&lt;li&gt;Default: make snapshots after every &lt;strong&gt;10 000 changes&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Tuning: Just in case that etcd&amp;rsquo;s memory and disk usage is too high, lower threshold.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Command line arguments:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;$ etcd --snapshot-count&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;5000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# Environment variables:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;$ &lt;span class="nv"&gt;ETCD_SNAPSHOT_COUNT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;5000&lt;/span&gt; etcd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="maintenance"&gt;Maintenance&lt;/h2&gt;
&lt;h3 id="history-compaction"&gt;History compaction&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Etcd keeps an exact history of its keyspace, the history should be periodically compacted to avoid performance degradation and eventual storage space exhaustion.&lt;/li&gt;
&lt;li&gt;Etcd can be set to automatically compact the keyspace with the &lt;code&gt;--auto-compaction-*&lt;/code&gt; option with a period of hours.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# keep one hour of history&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;$ etcd --auto-compaction-retention&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; --auto-compaction-mode&lt;span class="o"&gt;=&lt;/span&gt;periodic
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Compaction modes:
&lt;ul&gt;
&lt;li&gt;Revision-based: &lt;code&gt;--auto-compaction-mode=revision --auto-compaction-retention=1000&lt;/code&gt; automatically Compact on &amp;ldquo;latest revision&amp;rdquo; - 1000 every 5-minute (when latest revision is 30000, compact on revision 29000). Use this when having a large keyspace.&lt;/li&gt;
&lt;li&gt;Periodic: &lt;code&gt;--auto-compaction-mode=periodic --auto-compaction-retention=72h&lt;/code&gt; automatically Compact with 72-hour retention window every 1-hour. Use this when having a huge number of revisions for a key-value pair.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="defragmentation"&gt;Defragmentation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Compacting old revisions internally fragments etcd by leaving gaps in backend database - &lt;code&gt;internal fragmentation&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Internal fragmentation space is available for use by etcd but unavailable to the host filesystem.&lt;/li&gt;
&lt;li&gt;Solution: Release this space back to the filesystem with defrag.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;$ etcdctl defrag
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;It should be run rather infrequently, as there is always going to be an unavoidable pause.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Etcd hardware: &lt;a href="https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/hardware.md"&gt;https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/hardware.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Etcd tuning: &lt;a href="https://github.com/etcd-io/etcd/blob/master/Documentation/tuning.md"&gt;https://github.com/etcd-io/etcd/blob/master/Documentation/tuning.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Etcd maintainence: &lt;a href="https://etcd.io/docs/v3.4.0/op-guide/maintenance/"&gt;https://etcd.io/docs/v3.4.0/op-guide/maintenance/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>